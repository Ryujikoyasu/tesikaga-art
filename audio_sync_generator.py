import librosa
import numpy as np
import scipy.signal
import os
import pprint

# This script is designed to be self-contained and robust.
# It does NOT import from src.config, to avoid errors if that file is broken.
# Instead, it imports from a helper file which it can create itself.

def analyze_audio_file(file_path):
    """Analyzes a single audio file and returns a chirp pattern list."""
    print(f"  Analyzing: {os.path.basename(file_path)}...")
    try:
        y, sr = librosa.load(file_path, sr=None)
    except Exception as e:
        print(f"    ERROR: Could not load {file_path}. Skipping. Error: {e}")
        return None

    amplitude_envelope = np.abs(y)
    if np.max(amplitude_envelope) < 1e-5:
        print("    Audio file is silent or empty.")
        return [(0.0, 0.0)]
        
    # Parameters for peak detection
    peak_threshold_ratio = 0.25 
    min_peak_separation_s = 0.08 
    flash_duration_s = 0.15

    height_threshold = np.max(amplitude_envelope) * peak_threshold_ratio
    distance_in_samples = int(min_peak_separation_s * sr)
    
    peaks, _ = scipy.signal.find_peaks(
        amplitude_envelope, 
        height=height_threshold, 
        distance=distance_in_samples
    )
    
    duration = librosa.get_duration(y=y, sr=sr)
    if len(peaks) == 0:
        print("    No significant peaks found.")
        return [(0.0, 0.0), (duration, 0.0)]

    peak_times = librosa.samples_to_time(peaks, sr=sr)
    
    pattern = []
    for t in peak_times:
        pattern.append((max(0, t - (flash_duration_s / 2)), 0.0))
        pattern.append((t, 1.2))
        pattern.append((t + (flash_duration_s / 2), 0.0))
        
    pattern.sort()
    
    # Clean up the pattern by merging very close points
    clean_pattern = [pattern[0]]
    for i in range(1, len(pattern)):
        if pattern[i][0] - clean_pattern[-1][0] < 0.01:
            if pattern[i][1] > clean_pattern[-1][1]: 
                clean_pattern[-1] = pattern[i]
        else:
            clean_pattern.append(pattern[i])

    # Ensure the pattern starts at time 0 and ends at the audio duration
    if not clean_pattern or clean_pattern[0][0] > 0.01:
        clean_pattern.insert(0, (0.0, 0.0))
    if clean_pattern[-1][0] < duration:
        clean_pattern.append((duration, 0.0))
        
    print(f"    Found {len(peak_times)} peaks. Pattern generated.")
    return clean_pattern

def build_new_config_file_content(bird_params, bird_cast):
    """
    Constructs the entire content of config.py from scratch as a single string.
    This is the most robust way to prevent syntax errors.
    """
    header = f"""# This file is auto-generated by audio_sync_generator.py. DO NOT EDIT MANUALLY.
import pygame
import os

PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

# --- Screen & World Scaling ---
VIEW_WIDTH = 800
VIEW_HEIGHT = 800
SCREEN_WIDTH = VIEW_WIDTH * 2
SCREEN_HEIGHT = VIEW_HEIGHT
WORLD_RADIUS = 350
MODEL_DIAMETER = 5.0
MODEL_RADIUS = MODEL_DIAMETER / 2.0

# --- File Paths ---
LED_FILE_PATH = os.path.join(PROJECT_ROOT, "assets", "data", "led_positions.csv")

# --- AI & Visual Tuning ---
LED_SPREAD_MULTIPLIER = 1.5
IDLE_DURATION_RANGE_FRAMES = (180, 400)
FORAGING_DURATION_RANGE_FRAMES = (120, 300)
EXPLORE_DISTANCE_RANGE_METERS = (1.5, 4.0)
HUMAN_STILLNESS_THRESHOLD_FRAMES = 180

# --- Bird Personality Parameters (with auto-generated sync patterns) ---
"""
    
    # Use pprint to format the dictionaries beautifully and consistently
    params_str = "BIRD_PARAMS = " + pprint.pformat(bird_params, indent=4, width=120)
    cast_str = "BIRDS_TO_SIMULATE = " + pprint.pformat(bird_cast, indent=4, width=120)
    
    return header + params_str + "\n\n# --- Simulation Cast ---\n" + cast_str + "\n"

def main():
    """Main function to analyze audio and rebuild the config file."""
    # --- The import is moved inside main() to ensure the helper file exists ---
    from src.config_structure import get_base_config, get_simulation_cast

    print("Starting audio analysis to generate light sync patterns...")
    
    PROJECT_ROOT = os.path.dirname(os.path.abspath(__file__))
    bird_params_base = get_base_config()
    simulation_cast = get_simulation_cast()

    for bird_id, params in bird_params_base.items():
        print(f"\nProcessing bird: {params['name_jp']} ({bird_id})")
        if 'sound_files' in params:
            new_patterns_dict = {}
            for sound_key, sound_path in params['sound_files'].items():
                full_path = os.path.join(PROJECT_ROOT, sound_path)
                generated_pattern = analyze_audio_file(full_path)
                if generated_pattern:
                    new_patterns_dict[sound_key] = generated_pattern
            bird_params_base[bird_id]['chirp_pattern'] = new_patterns_dict
    
    # Rebuild the entire config.py content as a string
    new_config_content = build_new_config_file_content(bird_params_base, simulation_cast)
    
    # Safely write the new content, completely overwriting the old file
    config_path = os.path.join(PROJECT_ROOT, 'src', 'config.py')
    try:
        with open(config_path, 'w', encoding='utf-8') as f:
            f.write(new_config_content)
        print(f"\nSUCCESS: Rebuilt '{config_path}' with new audio-synced patterns!")
    except Exception as e:
        print(f"\nFATAL ERROR: Could not write to '{config_path}'. Error: {e}")

if __name__ == "__main__":
    # This block runs first. It ensures the helper file with base parameters exists.
    config_structure_path = os.path.join("src", "config_structure.py")
    
    if not os.path.exists(config_structure_path):
        print("Helper file 'src/config_structure.py' not found. Creating it...")
        os.makedirs("src", exist_ok=True) # Ensure 'src' directory exists
        helper_content = """# This file is a backup of the base bird parameters.
# It is used by audio_sync_generator.py to prevent read errors from a broken config.
def get_base_config():
    return {
        "ooluri": {"name_jp": "オオルリ", "led_color": [20, 100, 240], "accent_color": [240, 240, 255], "color_ratio": [8, 2], "size": 1.0, "movement_speed": 0.2, "approach_speed": 0.1, "curiosity": 0.5, "caution_distance": 1.5, "flee_distance": 1.0, "sound_files": {"default": "assets/sounds/oruri.mp3"}},
        "oohakucho": {"name_jp": "オオハクチョウ", "led_color": [255, 255, 255], "accent_color": [255, 220, 0], "color_ratio": [9, 1], "size": 4.0, "movement_speed": 0.08, "approach_speed": 0.02, "curiosity": 0.1, "caution_distance": 2.2, "flee_distance": 1.8, "sound_files": {"default": "assets/sounds/ohakucho.mp3"}},
        "ojirowasi": {"name_jp": "オジロワシ", "led_color": [180, 160, 140], "accent_color": [255, 255, 255], "color_ratio": [7, 3], "size": 5.0, "movement_speed": 0.05, "approach_speed": 0.0, "curiosity": 0.0, "caution_distance": 3.0, "flee_distance": 1.2, "sound_files": {"default": "assets/sounds/ojirowasi.mp3"}},
        "shimafukuro": {"name_jp": "シマフクロウ", "led_color": [80, 70, 60], "accent_color": [120, 110, 100], "color_ratio": [9, 1], "size": 4.5, "movement_speed": 0.1, "approach_speed": 0.0, "curiosity": 0.01, "caution_distance": 3.5, "flee_distance": 2.8, "sound_files": {"default": "assets/sounds/simafukuro.mp3"}},
        "kumagera": {"name_jp": "クマゲラ", "led_color": [20, 20, 20], "accent_color": [255, 0, 0], "color_ratio": [9, 1], "size": 1.5, "movement_speed": 0.3, "approach_speed": 0.1, "curiosity": 0.2, "caution_distance": 1.8, "flee_distance": 1.2, "sound_files": {"call": "assets/sounds/kumagera.mp3", "drumming": "assets/sounds/kumagera_drum.mp3"}},
        "tancho": {"name_jp": "タンチョウ", "led_color": [255, 255, 255], "accent_color": [220, 0, 0], "color_ratio": [8, 2], "size": 3.5, "movement_speed": 0.1, "approach_speed": 0.05, "curiosity": 0.3, "caution_distance": 2.5, "flee_distance": 2.0, "sound_files": {"default": "assets/sounds/tancho.mp3"}},
        "nogoma": {"name_jp": "ノゴマ", "led_color": [120, 110, 90], "accent_color": [255, 10, 10], "color_ratio": [9, 1], "size": 0.8, "movement_speed": 0.4, "approach_speed": 0.2, "curiosity": 0.8, "caution_distance": 2.0, "flee_distance": 1.5, "sound_files": {"default": "assets/sounds/nogoma.mp3"}},
        "benimashiko": {"name_jp": "ベニマシコ", "led_color": [220, 40, 80], "accent_color": [139, 69, 19], "color_ratio": [7, 3], "size": 0.9, "movement_speed": 0.35, "approach_speed": 0.15, "curiosity": 0.7, "caution_distance": 2.2, "flee_distance": 2.0, "sound_files": {"default": "assets/sounds/benimasiko.mp3"}}
    }

def get_simulation_cast():
    return ["ojirowasi", "shimafukuro", "tancho", "oohakucho", "oohakucho", "ooluri", "kumagera", "nogoma", "nogoma", "benimashiko", "benimashiko", "benimashiko"]
"""
        with open(config_structure_path, 'w', encoding='utf-8') as f:
            f.write(helper_content)

    # Now that we're sure the helper file exists, we can finally call main().
    main()