import os
import sys
import numpy as np
import librosa
from src.config_structure import get_base_config

PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.insert(0, PROJECT_ROOT)
CONFIG_PATH = os.path.join(PROJECT_ROOT, "src", "config.py")

def analyze_chirp(file_path):
    try:
        y, sr = librosa.load(file_path)
        # By adding a 'delta' parameter, we set a minimum threshold for onset strength.
        # This should be a more precise way to ignore noise without silencing actual chirps.
        onset_frames = librosa.onset.onset_detect(y=y, sr=sr, units='frames', hop_length=512, backtrack=True, energy=y**2, delta=0.1)
        onset_times = librosa.frames_to_time(onset_frames, sr=sr, hop_length=512)
        
        if not onset_times.any():
            return [(0.0, 0.0), (librosa.get_duration(y=y, sr=sr), 0.0)]
            
        events = [(0.0, 0.0)]
        last_time = 0.0
        
        for t in onset_times:
            if t > last_time + 0.05:
                events.append((np.float64(last_time), 0.0))
                events.append((np.float64(t), 1.2))
                last_time = t + 0.075
        
        events.append((np.float64(last_time), 0.0))
        final_duration = librosa.get_duration(y=y, sr=sr)
        if final_duration > last_time:
            events.append((final_duration, 0.0))
            
        return events
    except Exception as e:
        print(f"  [ERROR] Could not process audio file {os.path.basename(file_path)}: {e}")
        return [(0, 0)]

def format_python_code(obj, indent=0):
    margin = ' ' * indent
    if isinstance(obj, dict):
        items = [f"{margin}    '{k}': {format_python_code(v, indent + 4)}" for k, v in obj.items()]
        return f"{{\n" + ",\n".join(items) + f"\n{margin}}}"
    if isinstance(obj, list):
        if not obj: return "[]"
        if isinstance(obj[0], tuple):
            items = [f"{margin}    {repr(tuple(i))}" for i in obj]
            return f"[\n" + ",\n".join(items) + f"\n{margin}]"
        else:
            items = [f"{margin}    {repr(i)}" for i in obj]
            return f"[\n" + ",\n".join(items) + f"\n{margin}]"
    return repr(obj)

def main():
    print("--- Starting audio sync pattern generation ---")
    bird_params = get_base_config()

    for bird_id, params in bird_params.items():
        print(f"Processing bird: {bird_id.capitalize()}")
        chirp_patterns = {}
        for sound_name, sound_path in params.get('sound_files', {}).items():
            full_path = os.path.join(PROJECT_ROOT, sound_path)
            if os.path.exists(full_path):
                print(f"  -> Analyzing '{sound_name}' ({sound_path})...")
                chirp_patterns[sound_name] = analyze_chirp(full_path)
            else:
                print(f"  [WARNING] Sound file not found: {full_path}")
        params['chirp_pattern'] = chirp_patterns
    
    print("\n--- Generating new 'src/config.py' ---")
    output_content = f"""# This file was auto-generated by audio_sync_generator.py. DO NOT EDIT MANUALLY.
# It defines bird personalities, colors, and audio-synced light patterns.
# Hardware settings and simulation cast are in 'settings.yaml'.
import numpy as np

BIRD_PARAMS = {format_python_code(bird_params, 4)}
"""
    try:
        with open(CONFIG_PATH, 'w', encoding='utf-8') as f:
            f.write(output_content)
        print(f"Successfully wrote new bird parameters to '{CONFIG_PATH}'")
    except Exception as e:
        print(f"FATAL: Failed to write to '{CONFIG_PATH}'. Error: {e}")
        sys.exit(1)
    print("\n--- All processes completed successfully ---")

if __name__ == '__main__':
    main()